#!/usr/bin/env perl 

#==================================================================================#
#                                  airss.pl                                        #
#==================================================================================#
#                                                                                  #
# This file is part of the AIRSS structure prediction package.                     #
#                                                                                  #
# AIRSS is free software; you can redistribute it and/or modify it under the terms #
# of the GNU General Public License version 2 as published by the Free Software    #
# Foundation.                                                                      #
#                                                                                  #
# This program is distributed in the hope that it will be useful, but WITHOUT ANY  #
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A  #
# PARTICULAR PURPOSE.  See the GNU General Public License for more details.        #           
#                                                                                  #
# You should have received a copy of the GNU General Public License along with this#
# program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street,#                   
# Fifth Floor, Boston, MA  02110-1301, USA.                                        #
#                                                                                  #
#----------------------------------------------------------------------------------#
# This main AIRSS script, generate and run random structures generated by buildcell#
#----------------------------------------------------------------------------------#
# Written by Chris Pickard, Copyright (c) 2005-2018                                #
#----------------------------------------------------------------------------------#
#                                                                                  #
#==================================================================================#

use strict;
use Getopt::Long;
use File::Copy;
use Time::HiRes qw (time);

sub usage {
  printf STDERR "\n";
  printf STDERR "      .o.       ooooo ooooooooo.    .oooooo..o  .oooooo..o \n";
  printf STDERR "     .888.      '888' '888   'Y88. d8P'    'Y8 d8P'    'Y8 \n";
  printf STDERR "    .8:888.      888   888   .d88' Y88bo.      Y88bo.      \n";
  printf STDERR "   .8' '888.     888   888ooo88P'   ':Y8888o.   ':Y8888o.  \n";
  printf STDERR "  .88ooo8888.    888   888'88b.         ':Y88b      ':Y88b \n";
  printf STDERR " .8'     '888.   888   888  '88b.  oo     .d8P oo     .d8P \n";
  printf STDERR "o88o     o8888o o888o o888o  o888o 8::88888P'  8::88888P'  \n";
  printf STDERR "                                                           \n";
  printf STDERR "          Ab Initio Random Structure Searching             \n";
  printf STDERR "          Chris J. Pickard   (cjp20\@cam.ac.uk)            \n";
  printf STDERR "                 Copyright (c) 2005-2018                   \n";
  printf STDERR "                                                           \n";
  printf STDERR "Please cite the following:                                 \n";
  printf STDERR "                                                           \n";
  printf STDERR "[1] C.J. Pickard and R.J. Needs, PRL 97, 045504 (2006)     \n";
  printf STDERR "[2] C.J. Pickard and R.J. Needs, JPCM 23, 053201 (2011)    \n";
  printf STDERR "\n";
  printf STDERR "Usage: airss.pl [-pressure] [-build] [-pp0] [-pp3] [-gulp] [-lammps] [-gap] [-psi4] [-cluster] [-slab] [-dos] [-workdir] [-max] [-num] [-amp] [-mode] [-minmode] [-sim] [-symm] [-nosymm] [-mpinp] [-steps] [-best] [-track] [-keep] [-seed]\n";
  printf STDERR "       -pressure f  Pressure (0.0)\n";
  printf STDERR "       -build       Build structures only (false)\n";
  printf STDERR "       -pp0         Use pair potentials rather than Castep (0D) (false)\n";
  printf STDERR "       -pp3         Use pair potentials rather than Castep (3D) (false)\n";
  printf STDERR "       -gulp        Use gulp rather than Castep (false)\n";
  printf STDERR "       -lammps      Use LAMMPS rather than Castep (false)\n";
  printf STDERR "       -gap         Use GAP through QUIP/QUIPPY/ASE (false)\n";
  printf STDERR "       -ps4         Use psi4 (false)\n";
  printf STDERR "       -vasp        Use VASP (false)\n";
  printf STDERR "       -cluster     Use cluster settings for symmetry finder (false)\n";
  printf STDERR "       -slab        Use slab settings (false)\n";
  printf STDERR "       -dos         Calculate DOS at Ef (false)\n";
  printf STDERR "       -workdir  s  Work directory ('.')\n";
  printf STDERR "       -max      n  Maximum number of structures (1000000)\n";
  printf STDERR "       -num      n  Number of trials (0)\n";
  printf STDERR "       -amp      f  Amplitude of move (-1.5)\n";
  printf STDERR "       -mode        Choose moves based on low lying vibrational modes (false)\n";
  printf STDERR "       -minmode  n  Lowest mode (4)\n";
  printf STDERR "       -sim      f  Threshold for structure similarity (0.0)\n";
  printf STDERR "       -symm     f  Symmetrise on-the-fly (0.0)\n";
  printf STDERR "       -nosymm   f  No symmetry (0)\n";
  printf STDERR "       -mpinp    n  Number of cores per mpi Castep (0)\n";
  printf STDERR "       -steps    n  Max number of geometry optimisation steps (400)\n";
  printf STDERR "       -best        Only keep the best structures for each composition (false)\n";
  printf STDERR "       -track       Keep the track of good structures during relax and shake (false)\n";
  printf STDERR "       -keep        Keep intermediate files (false)\n";
  printf STDERR "       -seed     s  Seedname ('NONE')\n";
  exit();
}

my ($opt_pressure,$opt_build,$opt_pp0,$opt_pp3,$opt_gulp,$opt_lammps,$opt_gap,$opt_psi4,$opt_vasp,$opt_cluster,$opt_slab,$opt_dos,$opt_workdir,$opt_max,$opt_num,$opt_amp,$opt_mode,$opt_minmode,$opt_sim,$opt_symm,$opt_nosymm,$opt_mpinp,$opt_steps,$opt_best,$opt_track,$opt_keep,$opt_seed,$opt_help) 
  = (0.0,0,0,0,0,0,0,0,0,0,0,0,".",1000000,0,-1.5,0,4,0.0,0.0,0,0,400,0,0,0,"NONE",0);

&GetOptions("pressure=f" => \$opt_pressure,
            "build"      => \$opt_build,
            "pp0"        => \$opt_pp0,
            "pp3"        => \$opt_pp3,
            "gulp"       => \$opt_gulp,
            "lammps"     => \$opt_lammps,
            "gap"        => \$opt_gap,
            "psi4"       => \$opt_psi4,
            "vasp"       => \$opt_vasp,
            "cluster"    => \$opt_cluster,
            "slab"       => \$opt_slab,
            "dos"        => \$opt_dos,
            "workdir=s"  => \$opt_workdir, 
            "max=n"      => \$opt_max,
            "num=n"      => \$opt_num,
            "amp=f"      => \$opt_amp,
            "mode"       => \$opt_mode,
            "minmode=n"  => \$opt_minmode,
            "sim=f"      => \$opt_sim,
            "symm=f"     => \$opt_symm,
            "nosymm"     => \$opt_nosymm,
	    "mpinp=n"    => \$opt_mpinp,
	    "steps=n"    => \$opt_steps,
	    "best"       => \$opt_best,
	    "track"      => \$opt_track,
	    "keep"       => \$opt_keep,
            "seed=s"     => \$opt_seed,
            "h|help"     => \$opt_help)|| &usage();

if ($opt_help or $opt_seed eq "NONE") {
  &usage();
}

# Initialise loop counters etc

my ($high_energy,$nt,$i,$j,$k) = (9999999999.999,0,0,0,0);

my $best_enthalpy=$high_energy;
my $best_structure="";

my $uniquehead=$opt_seed."-".$$;
my $timestamp=time()*1000000%10000;
my $uniquenew = $uniquehead."-".$timestamp;

if ($opt_num < 0) {
  $opt_num=100000000000000000000000;
}

# Define the executable to be used

my $executable= '';
if ( $opt_vasp ) {
  $executable= 'vasp';
  if ($opt_mpinp > 0 ) {
    $executable= '"mpirun -np '.$opt_mpinp.' vasp"';
  }
} else {
  $executable= 'castep';
  if ($opt_mpinp > 0 ) {
    $executable= '"mpirun -np '.$opt_mpinp.' castep"';
  }
}
  
# Make work directory

system "mkdir -p $opt_workdir";

if ( -e $opt_seed.".cell" ) {
  copy($opt_seed.".cell",$opt_workdir."/".$uniquenew.".cell")
} else {
  print "<seed>.cell not found\n";
  exit
}

# The main loop over random structures

for ($i = 1; $i <= $opt_max; $i++) {
    
  $nt=$nt+1;
    
  # Set the unique file names

  my $unique = $uniquehead."-".$timestamp."-".$i;
     
  # Make a link to the seed param or pp
    
  if ( $opt_pp3 || $opt_lammps ) {
    copy($opt_seed.".pp",$opt_workdir."/".$unique.".pp");
  } elsif ( $opt_vasp )  {
    copy($opt_seed.".POTCAR",$opt_workdir."/".$unique.".POTCAR");
    my $vasp_pressure=10.0*$opt_pressure;
    system "(grep -v PSTRESS $opt_seed.INCAR ; echo PSTRESS = $vasp_pressure)  > $opt_workdir/$unique.INCAR";
  } else {
    copy($opt_seed.".param",$opt_workdir."/".$unique.".param");  
  }

  if ( ! $opt_mode || $j == 0) {
      
    # Generate a random structure based on the directives in the seed cell
            
    system "buildcell < $opt_workdir/$uniquenew.cell > $opt_workdir/$unique.cell 2> /dev/null";   
      
  } else {

    # Push a structure along a mode

    my $nions=`grep ions $uniquenew.phonon | awk '{printf \$4}'`;
    my $nbranches=`grep branches $uniquenew.phonon | awk '{printf \$4}'`;
  
    system "sed -n -e '1,/^%BLOCK positions/p' $uniquenew.cell > $unique.top";
    system "sed -n -e '/^%BLOCK [Pp][Oo][Ss]*/, /^%ENDBLOCK [Pp][Oo][Ss]*/p' $uniquenew.cell | sed '\$d' | sed '1d' > $unique.ions";
    system "sed -n -e '/^%ENDBLOCK [Pp][Oo][Ss]*/,\$p' $uniquenew.cell > $unique.bottom";
    
    my @latt=`sed -n -e '/^ Unit cell*/, /^ Frac*/p' $uniquenew.phonon | head -4 | tail -3`;
    
    my $nmode=int(($j+1)/2)+$opt_minmode-1;

    my $sign=(-1)**$j;
   
    my $ntail=$nions*($nbranches+1-$nmode);
    system "tail -$ntail $uniquenew.phonon | head -$nions | awk '{print \$3,\$5,\$7}' > $unique.mode";
    my @mode=`cat $unique.mode`;

	
    my $maxdist=0;
    foreach (@mode) {
      my $dist=0.0;
      my @vec = split(' ',$_);
      foreach (@latt) {
	my @latvec = split(' ',$_);
	$dist = $dist + ($latvec[0]*$vec[0]+$latvec[1]*$vec[1]+$latvec[2]*$vec[2])**2;
      }
      if (sqrt($dist) > $maxdist) {
	$maxdist=sqrt($dist);
      }
    }
   
    my $step=$sign*$opt_amp/$maxdist;

    system "cat $unique.top > $unique.cell";
    system "paste $unique.ions $unique.mode | awk '{print \$1,\$2+$step*\$5,\$3+$step*\$6,\$4+$step*\$7}' >> $unique.cell";
    system "cat $unique.bottom >> $unique.cell";
    system "rm -f $unique.top $unique.ions $unique.mode $unique.bottom";
   
  }
    
  # Add chosen external pressure
    
  open  CELLFILE, ">>$opt_workdir/$unique.cell" or die $!;
  print CELLFILE "%BLOCK EXTERNAL_PRESSURE\n";
  print CELLFILE  $opt_pressure," 0 0 \n";
  print CELLFILE  $opt_pressure," 0\n";
  print CELLFILE  $opt_pressure,"\n";
  print CELLFILE "%ENDBLOCK EXTERNAL_PRESSURE\n";
  close CELLFILE;
    
  # Perform the optimisation and store the results
    
  my @results='';

  if ( $opt_pp0 ) {
    @results=`pp0_relax pp0 $opt_workdir/$unique`;
  } elsif ( $opt_pp3 )  {
    @results=`pp3_relax pp3 $opt_workdir/$unique`;    
  } elsif ( $opt_build )  {
    @results="Volume: 0.00000001";
  } elsif ( $opt_gulp ) {
    if ( $opt_slab || $opt_cluster ) {
      @results=`gulp_relax gulp 1 $opt_pressure $opt_workdir/$unique`;
    } else {
      @results=`gulp_relax gulp 0 $opt_pressure $opt_workdir/$unique`;
    }
  } elsif ( $opt_lammps )  {
    @results=`lammps_relax lammps $opt_pressure $opt_workdir/$unique`;
  } elsif ( $opt_gap )  {
    @results=`gap_relax ase_relax_cell.py $opt_workdir/$unique`;
  } elsif ( $opt_psi4 )  {
    @results=`psi4_relax psi4 $opt_workdir/$unique`;
  } elsif ( $opt_vasp )  {
    @results=`vasp_relax $executable $opt_workdir/$unique`;
  } else {     
    @results=`castep_relax $opt_steps $executable $opt_sim $opt_symm $opt_workdir/$unique`;
  }
 
  my $p=0;
  my $enthalpy=0;
  my $volume=0;
  foreach (@results) {
    my @tmp = split(' ',$_);
    if ($tmp[0] eq "Pressure:") {
      $p       =$tmp[1];
    }
    if ($tmp[0] eq "Enthalpy:") {
      $enthalpy=$tmp[1];
    }
    if ($tmp[0] eq "Volume:") {
      $volume  =$tmp[1];
    }
  }
     
  if ( ($enthalpy < $best_enthalpy) && ($volume > 0) ) {

    if ( ! $opt_track) {
      if (length($best_structure)>0) {
	system "rm -f $best_structure.* $opt_workdir/$best_structure.*";
      }
    }

    $best_structure = $unique;
	
    # If we are doing RASH

    if ($opt_num > 0) {
      $best_enthalpy = $enthalpy;
      $j=0;
    }

    # Calculate the DOS at the Fermi level

    if ($opt_dos) {
      system("(echo 'task : spectral' ; echo 'spectral_task : dos' ; grep -E -i -v 'task|write_bands' $opt_workdir/$unique.param ) > $opt_workdir/$unique-dos.param; cp $opt_workdir/$unique.cell $opt_workdir/$unique-dos.cell;eval $executable $opt_workdir/$unique-dos");
      system("(echo 'task : dos';echo 'broadening : linear'; echo 'compute_band_gap : true')>$opt_workdir/$unique-dos.odi;optados $opt_workdir/$unique-dos");
    }

    # Convert the structure to SHLX file, adding results, and computational parameters
    
    if ($opt_nosymm == 0) {
      system("castep2res $opt_cluster $opt_workdir/$unique > $opt_workdir/$unique.res");
    } else {
      system("castep2res -1 $opt_workdir/$unique > $opt_workdir/$unique.res");
    }
    
    # Identify and remove repeated structure, keeping track of the number of encounters (not needed if castep_relax is used)
    
    #if ($opt_sim > 0 && ($opt_pp3 || $opt_gulp) ) {
    if ($opt_sim > 0 ) {

      my $known ='';
      if ($opt_workdir eq ".") {
	$known = `find . -name "*.res" | xargs cat | cryan -c $opt_sim $unique 2> /dev/null | awk '{print \$1}' | head -1`;
      } else {
	# FIX THIS ...
	$known = '';
      }
      chomp($known);

      if ($known ne '') {
	my $knowntitl=`grep TITL $opt_workdir/$known.res | awk 'BEGIN {FS="n -"};{print \$1}'`;
	my $num_repeats=1+`grep TITL $opt_workdir/$known.res | awk 'BEGIN {FS="n -"};{print \$2}'`;
	chomp($knowntitl);

	open  RESFILE, "$opt_workdir/$known.res" or die $!;
	my @resdata = <RESFILE>;
	close RESFILE;
	open  RESFILE, ">$opt_workdir/$known.res" or die $!;
	shift(@resdata);
	unshift(@resdata,$knowntitl."n - ".$num_repeats."\n");
	print RESFILE @resdata;
	close RESFILE;

	if (! $opt_keep) {
	  system "rm -fr $opt_workdir/$unique*";
	} else {
	  system "mkdir -p $opt_workdir/trash ; mv $opt_workdir/$unique* $opt_workdir/trash";
	}
	next;
      }
      
    }

    # Calculate the vibrational modes

    if ( $opt_mode) {
      system "sed -e 's/geometryoptimization/thermodynamics/g' $opt_workdir/$unique.param > $opt_workdir/$unique.param.temp;
          echo 'phonon_method : finitedisplacement\nphonon_sum_rule : true\ncalculate_born_charges : false\nphonon_calc_lo_to_splitting : false' >> $opt_workdir/$unique.param.temp;
          echo 'PHONON_KPOINT_MP_GRID : 1 1 1' >> $opt_workdir/$unique.cell;
          mv $opt_workdir/$unique.param.temp $opt_workdir/$unique.param;
          eval $executable $opt_workdir/$unique;
          mv $opt_workdir/$unique.phonon $opt_workdir/$uniquenew.phonon";
    }

    # Make the current cell the new reference structure to shake
	
    updatepos ($opt_workdir."/".$uniquenew.".cell",$opt_workdir."/".$unique.".cell");
		
  } else {

    # Remove the output of the "failed" run
	
    if (! $opt_keep) {
      system "rm -fr $opt_workdir/$unique*";
    } else {
      system "mkdir -p $opt_workdir/trash ; mv $opt_workdir/$unique* $opt_workdir/trash";
    }
	
  }

  if ( $j < $opt_num ) {
    $j=$j+1;
    if ( $opt_amp < 0 ) {copy($opt_seed . ".cell",$opt_workdir."/".$uniquenew.".cell")};
  } else {
    $j=0;
    $best_enthalpy = $high_energy;
    $best_structure = "";
    copy($opt_seed . ".cell",$opt_workdir."/".$uniquenew.".cell");
  }

  if (! $opt_keep) {
    my @delete_files = <$opt_workdir/$unique*>;
    foreach (@delete_files) {if (($_ ne "$opt_workdir/$unique.res")&&($_ ne "$opt_workdir/$unique.conv")) {unlink($_);}}
    if ( $opt_vasp ) {
      my @delete_files = <$opt_workdir/$unique/*>;
      foreach (@delete_files) {unlink($_)};
      rmdir <$opt_workdir/$unique>;
    }
  }

  if ( $opt_best ) {
    my $best_formula='';
    if ( $opt_cluster ) {
      $best_formula=`cryan -r < $opt_workdir/$unique.res | awk '{print \$(NF-3),\$(NF-2)}'`;
    } else {
      $best_formula=`cryan -r < $opt_workdir/$unique.res | awk '{print \$(NF-2)}'`;
    }
    print $best_formula."\n";
    chomp($best_formula);    
    my $best_struct=`(find . -maxdepth 1 -name "*.res" ; echo $opt_workdir/$unique.res) | xargs cat | cryan -r | grep "$best_formula" | head -1 | awk '{print \$1}'`;
    chomp($best_struct);
    if ( $unique ne $best_struct ) {
      system "rm -fr $opt_workdir/$unique*";
    }
  }
    
  # Use rsync to copy files from the work directory

  if ($opt_workdir ne ".") {
    system "rsync -t $opt_workdir/$uniquehead* .";
  }
}


sub updatepos {

  my $oldcell=shift;
  my $newcell=shift;

  system "sed -n -e '/^%BLOCK [Ll][Aa][Tt]*/, /^%ENDBLOCK [Pp][Oo][Ss]*/p' $newcell > $newcell.temp;
    sed -e '/ANG/d' $newcell.temp > $oldcell.temp;
    sed -e '/^%BLOCK [Ll][Aa][Tt]*/, /^%ENDBLOCK [Pp][Oo][Ss]*/d' $oldcell >> $oldcell.temp;
    sed -e 's/%ENDBLOCK [Ll][Aa][Tt]/\#FIX^%ENDBLOCK lat/g' $oldcell.temp | tr '^' '\n' | sed -e 's/latTICE/LATTICE/g' | grep -v '\#POSAMP=' | grep -v '\#SYMM' | grep -v '\#NFORM=' | grep -v '\#SUPER' > $oldcell;
    echo '\#POSAMP=$opt_amp' >> $oldcell;
    rm $newcell.temp $oldcell.temp;";

}

